# 内存泄漏

内存被分配后没有被释放，会导致内存泄漏。

所以我们需要垃圾回收机制来防止这种问题。

可以通过 Dev tools 的 performance monitor 检查。



# JS 中的垃圾回收

浏览器的 JS 具有自动的垃圾回收机制。垃圾收集器会定期（周期性的）找出存在但是不继续使用的变量，然后释放其内容。

主要有以下方式：

1. 新生代老生代
2. 引用计数
3. 增量标记（优化）



## 新生代和老生代

### 新生代

空间只有 **64 MB**，分为 from/to 两个空间

Copy复制  Scavenge算法（新生代互换）

新生代中存放的是**生存时间比较短的对象**



#### 流程

1. 从根对象开始，遍历所有引用，标记可达对象
2. **复制阶段**：将存活的对象从 From 区域复制到 To 区域
3. **清除阶段**：清理 From 区域对象，并交换 From 和 To 区域



#### 拓展：为什么需要用copy？

牺牲空间换时间



### 老生代

空间有 **1400MB**

做标记整理清除。Mark-Sweep（标记清除）+ Mark-Compact（标记整理）

老生代中存放的是**生存时间长的对象**



#### 标记清除

1. GC 根节点
2. 做广度扫描，根 GC 根节点相关的互相连接起来
3. 把被引用的变量标记出来（不是垃圾）
4. 把没有标记的变量清除

<img src="/Users/lujiema/Library/Application Support/typora-user-images/Screenshot 2025-03-01 at 7.48.42 PM.png" alt="Screenshot 2025-03-01 at 7.48.42 PM" style="zoom:50%;" />



#### 标记整理

1. 做广度扫描
2. 将跟 GC 根节点相关的做标记
3. 将被标记的节点做整理
4. 对剩下的空间做清除

<img src="/Users/lujiema/Library/Application Support/typora-user-images/Screenshot 2025-03-01 at 7.49.45 PM.png" alt="Screenshot 2025-03-01 at 7.49.45 PM" style="zoom:50%;" />



#### 拓展：为什么要整理？一定需要先整理再清除吗？

1. 因为在做整理的时候，会把原来一些不需要的变量顺便覆盖了，减少了需要清理的变量数量；
2. 因为内存空间是连续的，如果整理完，只需要直接清除就可以了。





## 引用计数

跟踪每个值被引用的次数

流程：

1. 申明了一个变量并将一个引用类型的值赋给这个变量，引用次数是1
2. 同一个值被赋值给另一个变量，引用次数+1
3. 包含这个引用类型的变量被赋值成另一个值了，引用次数+1
4. 当引用次数是0的时候，说明这个值没法被访问
5. 垃圾回收器下一次运行的时候，会释放引用次数是0的值



## 增量标记（优化）

会把标记过程分成好几个步骤，分批次进行，这样子不会影响浏览器的线程，减少卡顿











