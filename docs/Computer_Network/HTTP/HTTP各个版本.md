# HTTP 1.0

### 无法复用连接

<img src="./images/Screenshot 2024-12-08 at 12.26.45 AM.png" alt="Screenshot 2024-12-08 at 12.26.45 AM" style="zoom:50%;" />

HTTP1.0 为每一个请求单独开一个 TCP 连接，造成的问题：

1. 连接的建立和销毁都会占用服务器和客户端的资源，造成内存资源的浪费。
2. 连接的建立和销毁都会消耗时间，造成响应时间的浪费
3. 无法充分利用带宽，造成带宽资源的浪费

> TCP 协议的特点是 **慢启动**，即一开始传输的数据量少，一段时间之后达到传输的峰值。而上面的做法，会导致大量的请求在TCP 达到传输峰值的时候被销毁。



### 队头堵塞

 <img src="./images/Screenshot 2024-12-08 at 12.24.52 AM.png" alt="Screenshot 2024-12-08 at 12.24.52 AM" style="zoom:50%;" />



每次资源的请求都需要开新的连接。



# HTTP 1.1

### 长连接

<img src="./images/Screenshot 2024-12-08 at 12.25.50 AM.png" alt="Screenshot 2024-12-08 at 12.25.50 AM" style="zoom:50%;" />

长连接就是多次请求响应可以共享一个 TCP，有效利用带宽。

> 可以关注一个请求头的字段： Connection: keep-alive，表示客户端希望开启长连接，希望服务器不要关闭 TCP 连接。如果服务器认可，即可保持 TCP 连接。



什么时候关闭 TCP 连接？

1. 客户端设置 Connection: close；
2. 客户端对服务器进行心跳检测，一旦心跳检测停止，服务器关闭。



### 管道化和队头堵塞

<img src="./images/Screenshot 2024-12-08 at 12.35.06 AM.png" alt="Screenshot 2024-12-08 at 12.35.06 AM" style="zoom:50%;" />

在 HTTP1.1 中，不需要每次重新建立连接，但是资源还是有堵塞问题。

> 例如先请求黄色的资源，虽然紫色的资源可以在黄色的资源没有处理完就可以请求，但是紫色的资源要等黄色的资源处理完才能够返回，这还是会造成堵塞。



 队头堵塞虽然发生在 **服务器**，但这个问题的根源是客户端无法知晓服务器的响应是针对哪个请求的。

正是由于存在队头堵塞，我们使用以下手段进行优化：

- 减少文件数量，减少队头堵塞的几率。（比如雪碧图）
- 通过开辟多个 TCP 连接，实现真正的，有缺陷的并行传输。（一个域名可以开6个，如果像 taobao.com 这种有很多图片的网站，可以使用不同的域名来实现）



### 缓存处理

新增 Cache-control，E-Tag 字段

详情可以看 [浏览器缓存](/Users/lujiema/Documents/前端/计算机网络/强缓存和协商缓存.md)



### 断点续传

1. 客户端使用 range 字段指定下载范围，请求下载的范围
2. 服务器响应，返回 206 状态码并且在 Content-Range 指定下载的范围





# HTTP 2.0

### 二进制分帧

HTTP2.0 可以允许以更小的单元传输数据，每个传输单元称之为帧，而每一个请求或响应的完整数据称之为流，每个流**有自己的编号**，每个帧会记录所属的流。

即使被打乱也可以在客户端被正确组装。



### 头部压缩

通过字典（静态表）的形式，将头部的常见信息替换成更少的字符，极大的减少了头部的数据量，从而实现更小的传输量。

> Haffman 算法也可以做到压缩



### 服务器推

HTTP 2.0 允许在客户端没有主动请求的情况下，服务器预先把资源推送给客户端，

当客户端后序需要请求该资源的时候，自动从之前推送的资源中寻找。





# HTTP 3.0

基于 QUIC 协议

### 无队头阻塞问题

因为 HTTP 2.0 始终基于 TCP 连接，TCP 连接始终要求传输的完整和连续，那么如果传输过程中有丢包，会触发 TCP 重传机制。

为了解决这个问题，HTTP 3.0 使用 UDP，因为 UDP 不存在丢包阻塞问题。QUIC 协议保证了 UDP 的传输完整性和连续性，如果发生丢包，只会影响自己的流，不会阻塞别的流



### 连接迁移

当用户从 WiFi 切换到 移动数据的时候，IP 地址会导致变化，如果是 HTTP2.0 的话，会需要重新创建连接。

但是因为 HTTP3.0 基于 QUIC 协议，它不依赖于 TCP/IP 的连接，凭借连接 ID 来标记两个通信节点，只要不丢失上下文信息，切换的时候可以实现无缝切换，用户体验更好。



### 零 RTT 连接建立

首次连接还是需要 1 RTT 来完成 TLS 的握手和连接建立。

但是后续的连接可以应用 QUIC 握手信息（连接信息+ TLS 握手信息），实现 0 RTT。



### 安全性

HTTP3.0 默认使用了 TLS 加密，更加的安全

























